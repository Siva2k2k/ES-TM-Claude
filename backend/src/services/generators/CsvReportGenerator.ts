import { ReportData } from '../ReportService';
import { logger } from '@/config/logger';

/**
 * CSV Report Generator
 * Generates CSV format reports from report data
 */
export class CsvReportGenerator {
  /**
   * Generate CSV content from report data
   */
  static async generate(reportData: ReportData): Promise<{ csv?: string; error?: string }> {
    try {
      const { data, metadata, template } = reportData;

      if (!data || data.length === 0) {
        return { csv: this.generateEmptyReport(template.name, metadata) };
      }

      // Generate CSV header and rows
      const headers = this.extractHeaders(data[0], template.template_id);
      const rows = data.map(record => this.convertToRow(record, headers));

      // Build CSV content
      const csvLines: string[] = [];

      // Add metadata header
      csvLines.push(`# ${metadata.report_name}`);
      csvLines.push(`# Generated: ${metadata.generated_at.toISOString()}`);
      csvLines.push(`# Generated By: ${metadata.generated_by}`);
      csvLines.push(`# Date Range: ${metadata.date_range.start.toISOString()} to ${metadata.date_range.end.toISOString()}`);
      csvLines.push(`# Total Records: ${metadata.total_records}`);
      csvLines.push('');

      // Add column headers
      csvLines.push(headers.join(','));

      // Add data rows
      rows.forEach(row => {
        csvLines.push(row.join(','));
      });

      const csv = csvLines.join('\n');

      logger.info(`CSV report generated: ${template.name} (${data.length} records)`);
      return { csv };
    } catch (error) {
      logger.error('Error generating CSV report:', error);
      return { error: 'Failed to generate CSV report' };
    }
  }

  /**
   * Extract headers from data object
   */
  private static extractHeaders(dataObject: any, templateId: string): string[] {
    // Define headers based on report template
    const headerMap: Record<string, string[]> = {
      'employee-payslip': ['Month', 'Year', 'Total Hours', 'Billable Hours', 'Hourly Rate', 'Gross Pay', 'Deductions', 'Net Pay'],
      'employee-timesheet-summary': ['Week Start', 'Week End', 'Total Hours', 'Status', 'Submitted At', 'Approved At'],
      'employee-performance': ['Period', 'Total Hours', 'Projects', 'Tasks Completed', 'Productivity Score'],
      'lead-team-timesheet': ['Employee', 'Week Start', 'Total Hours', 'Status', 'Submitted At'],
      'manager-project-performance': ['Project', 'Client', 'Status', 'Budget', 'Hours Spent', 'Budget Utilization %'],
      'manager-project-financial': ['Project', 'Revenue', 'Cost', 'Margin', 'Billable Hours', 'ROI %'],
      'default': Object.keys(dataObject).filter(key => !key.startsWith('_') && key !== '__v')
    };

    return headerMap[templateId] || headerMap['default'];
  }

  /**
   * Convert data object to CSV row
   */
  private static convertToRow(dataObject: any, headers: string[]): string[] {
    return headers.map(header => {
      const key = header.toLowerCase().replace(/ /g, '_');
      let value = dataObject[key];

      // Handle nested objects
      if (typeof value === 'object' && value !== null) {
        if (value.name) value = value.name;
        else if (value.toString) value = value.toString();
        else value = JSON.stringify(value);
      }

      // Escape commas and quotes
      if (typeof value === 'string') {
        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
          value = `"${value.replace(/"/g, '""')}"`;
        }
      }

      return value || '';
    });
  }

  /**
   * Generate empty report with message
   */
  private static generateEmptyReport(reportName: string, metadata: any): string {
    return [
      `# ${reportName}`,
      `# Generated: ${metadata.generated_at.toISOString()}`,
      `# Generated By: ${metadata.generated_by}`,
      '',
      'No data available for the selected criteria.'
    ].join('\n');
  }

  /**
   * Save CSV to file
   */
  static async saveToFile(csv: string, filename: string): Promise<{ success: boolean; path?: string; error?: string }> {
    try {
      const fs = require('fs').promises;
      const path = require('path');

      const reportsDir = path.join(process.cwd(), 'reports', 'generated');

      // Ensure directory exists
      await fs.mkdir(reportsDir, { recursive: true });

      const filePath = path.join(reportsDir, filename);
      await fs.writeFile(filePath, csv, 'utf8');

      logger.info(`CSV report saved to: ${filePath}`);
      return { success: true, path: filePath };
    } catch (error) {
      logger.error('Error saving CSV report:', error);
      return { success: false, error: 'Failed to save CSV report' };
    }
  }
}

export default CsvReportGenerator;
