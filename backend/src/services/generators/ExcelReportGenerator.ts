import { ReportData } from '../ReportService';
import { logger } from '@/config/logger';
import ExcelJS from 'exceljs';

/**
 * Excel Report Generator
 * Generates Excel format reports with formatting and charts
 */
export class ExcelReportGenerator {
  /**
   * Generate Excel workbook from report data
   */
  static async generate(reportData: ReportData): Promise<{ buffer?: Buffer; error?: string }> {
    try {
      const { data, metadata, template } = reportData;

      const workbook = new ExcelJS.Workbook();
      workbook.creator = metadata.generated_by;
      workbook.created = metadata.generated_at;
      workbook.modified = metadata.generated_at;

      // Add main data sheet
      const worksheet = workbook.addWorksheet('Report Data');

      // Add header with metadata
      this.addReportHeader(worksheet, metadata);

      // Add data table
      if (data && data.length > 0) {
        this.addDataTable(worksheet, data, template.template_id);
      } else {
        worksheet.addRow(['No data available for the selected criteria.']);
      }

      // Add summary sheet if applicable
      if (['manager', 'management', 'super_admin'].includes(metadata.filters_applied.role)) {
        this.addSummarySheet(workbook, data, template);
      }

      // Generate buffer
      const buffer = await workbook.xlsx.writeBuffer();

      logger.info(`Excel report generated: ${template.name} (${data.length} records)`);
      return { buffer: buffer as unknown as Buffer };
    } catch (error) {
      logger.error('Error generating Excel report:', error);
      return { error: 'Failed to generate Excel report' };
    }
  }

  /**
   * Add report header with metadata
   */
  private static addReportHeader(worksheet: ExcelJS.Worksheet, metadata: any): void {
    // Title row
    const titleRow = worksheet.addRow([metadata.report_name]);
    titleRow.font = { size: 16, bold: true, color: { argb: 'FF1F4788' } };
    titleRow.height = 25;

    // Metadata rows
    worksheet.addRow(['Generated:', metadata.generated_at.toLocaleString()]);
    worksheet.addRow(['Generated By:', metadata.generated_by]);
    worksheet.addRow(['Date Range:', `${metadata.date_range.start.toLocaleDateString()} to ${metadata.date_range.end.toLocaleDateString()}`]);
    worksheet.addRow(['Total Records:', metadata.total_records]);
    worksheet.addRow([]);

    // Style metadata rows
    for (let i = 2; i <= 5; i++) {
      const row = worksheet.getRow(i);
      row.getCell(1).font = { bold: true };
      row.getCell(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE7E6E6' }
      };
    }
  }

  /**
   * Add data table with formatting
   */
  private static addDataTable(worksheet: ExcelJS.Worksheet, data: any[], templateId: string): void {
    const headers = this.getColumnHeaders(templateId);
    const columns = this.getColumnDefinitions(headers);

    // Add headers
    worksheet.columns = columns;

    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' }
    };
    headerRow.height = 20;

    // Add data rows
    data.forEach(record => {
      const row = this.extractRowData(record, headers, templateId);
      worksheet.addRow(row);
    });

    // Auto-fit columns
    worksheet.columns.forEach(column => {
      if (column.header) {
        column.width = Math.max(12, column.header.toString().length + 2);
      }
    });

    // Add filters
    worksheet.autoFilter = {
      from: { row: 7, column: 1 },
      to: { row: 7, column: headers.length }
    };

    // Freeze header row
    worksheet.views = [
      { state: 'frozen', xSplit: 0, ySplit: 7 }
    ];
  }

  /**
   * Get column headers based on template
   */
  private static getColumnHeaders(templateId: string): string[] {
    const headerMap: Record<string, string[]> = {
      'employee-payslip': ['Month', 'Year', 'Total Hours', 'Billable Hours', 'Hourly Rate', 'Gross Pay', 'Deductions', 'Net Pay'],
      'employee-timesheet-summary': ['Week Start', 'Week End', 'Total Hours', 'Status', 'Submitted At', 'Approved At'],
      'employee-performance': ['Period', 'Total Hours', 'Projects', 'Tasks Completed', 'Productivity Score'],
      'lead-team-timesheet': ['Employee', 'Email', 'Week Start', 'Total Hours', 'Status', 'Submitted At'],
      'lead-team-performance': ['Employee', 'Total Hours', 'Projects', 'Productivity Score', 'Rating'],
      'manager-project-performance': ['Project', 'Client', 'Status', 'Budget', 'Hours Spent', 'Budget Utilization %', 'Timeline Status'],
      'manager-project-financial': ['Project', 'Revenue', 'Cost', 'Margin', 'Billable Hours', 'ROI %', 'Profit'],
      'manager-resource-allocation': ['Employee', 'Role', 'Allocated Hours', 'Available Hours', 'Utilization %', 'Projects'],
      'management-financial-dashboard': ['Period', 'Revenue', 'Cost', 'Profit', 'Margin %', 'Growth %'],
      'management-org-utilization': ['Department', 'Employees', 'Total Hours', 'Billable Hours', 'Utilization %'],
      'default': ['ID', 'Name', 'Value', 'Status', 'Created At']
    };

    return headerMap[templateId] || headerMap['default'];
  }

  /**
   * Get column definitions for Excel
   */
  private static getColumnDefinitions(headers: string[]): Partial<ExcelJS.Column>[] {
    return headers.map(header => ({
      header,
      key: header.toLowerCase().replace(/ /g, '_'),
      width: 15
    }));
  }

  /**
   * Extract row data from record
   */
  private static extractRowData(record: any, headers: string[], templateId: string): any[] {
    return headers.map(header => {
      const key = header.toLowerCase().replace(/ /g, '_');
      let value = record[key];

      // Handle nested objects
      if (typeof value === 'object' && value !== null) {
        if (value.name) return value.name;
        if (value.email) return value.email;
        if (value instanceof Date) return value.toLocaleDateString();
        return JSON.stringify(value);
      }

      // Format dates
      if (value instanceof Date) {
        return value.toLocaleDateString();
      }

      // Format numbers
      if (typeof value === 'number' && header.includes('%')) {
        return `${(value * 100).toFixed(2)}%`;
      }

      return value || '';
    });
  }

  /**
   * Add summary sheet with aggregations
   */
  private static addSummarySheet(workbook: ExcelJS.Workbook, data: any[], template: any): void {
    const summarySheet = workbook.addWorksheet('Summary');

    summarySheet.addRow(['Report Summary']);
    summarySheet.getRow(1).font = { size: 14, bold: true };

    summarySheet.addRow([]);

    if (data.length > 0) {
      // Add basic statistics
      summarySheet.addRow(['Total Records:', data.length]);

      // Calculate totals based on template type
      if (template.category === 'financial') {
        const totalRevenue = data.reduce((sum, r) => sum + (r.revenue || r.total_amount || 0), 0);
        const totalCost = data.reduce((sum, r) => sum + (r.cost || 0), 0);
        const totalProfit = totalRevenue - totalCost;

        summarySheet.addRow(['Total Revenue:', totalRevenue]);
        summarySheet.addRow(['Total Cost:', totalCost]);
        summarySheet.addRow(['Total Profit:', totalProfit]);
        summarySheet.addRow(['Profit Margin:', `${((totalProfit / totalRevenue) * 100).toFixed(2)}%`]);
      } else if (template.category === 'personal' || template.category === 'team') {
        const totalHours = data.reduce((sum, r) => sum + (r.total_hours || 0), 0);
        summarySheet.addRow(['Total Hours:', totalHours.toFixed(2)]);
        summarySheet.addRow(['Average Hours:', (totalHours / data.length).toFixed(2)]);
      }
    }

    // Style summary sheet
    summarySheet.getColumn(1).width = 20;
    summarySheet.getColumn(2).width = 15;
  }

  /**
   * Save Excel to file
   */
  static async saveToFile(buffer: Buffer, filename: string): Promise<{ success: boolean; path?: string; error?: string }> {
    try {
      const fs = require('fs').promises;
      const path = require('path');

      const reportsDir = path.join(process.cwd(), 'reports', 'generated');
      await fs.mkdir(reportsDir, { recursive: true });

      const filePath = path.join(reportsDir, filename);
      await fs.writeFile(filePath, buffer);

      logger.info(`Excel report saved to: ${filePath}`);
      return { success: true, path: filePath };
    } catch (error) {
      logger.error('Error saving Excel report:', error);
      return { success: false, error: 'Failed to save Excel report' };
    }
  }
}

export default ExcelReportGenerator;
